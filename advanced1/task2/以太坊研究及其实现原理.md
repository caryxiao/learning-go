Geth（Go-Ethereum）是以太坊官方客户端之一，使用 Go 语言编写，长期作为以太坊主网中最重要的全节点客户端之一。它在以太坊生态中扮演着 **执行层客户端（Execution Layer Client）** 的角色，与共识层客户端（如Prysm、Lighthouse）配合构成完整的以太坊节点。Geth 主要负责区块执行、交易处理、状态存储与同步、EVM 执行、P2P 网络通信等任务。

## 一、Geth 在以太坊生态中的定位

Geth 是连接以太坊网络和用户/开发者的核心桥梁，主要承担以下职责：

- 实现以太坊协议规范（EIP，黄皮书）
- 运行执行层逻辑（EVM、交易池、状态更新、数据库存储）
- 提供 JSON-RPC 接口服务，与 dApp、钱包、Web3 库等交互
- 管理区块同步、节点发现、P2P 网络通信
- 实现与共识层（如信标链客户端）的接口通信（Engine API）

## 二、分层架构图
分层架构图大概描述了整Geth的逻辑模型
![分层架构图](Go-Ethereum（Geth）分层架构图.png)

## 三、交易生命周期流程图
交易生命周期流程图用于了解整个交易的生命周期中需要经过哪些步骤才能最终上链
![交易生命周期流程图](交易生命周期流程图.png)

## 四、核心模块及交互关系

### 1. 区块链同步协议（eth/62、eth/63）

Geth 使用基于 devp2p 的 `eth/62` 和 `eth/63` 协议来实现节点间的区块链数据同步：

| 协议版本 | 功能概述                                                     |
| -------- | ------------------------------------------------------------ |
| `eth/62` | 支持区块头、区块体、收据（receipts）同步                     |
| `eth/63` | 引入 `GetNodeData` 和 `GetReceipts`，支持 MPT 状态树节点请求 |

Geth 的区块同步分为两种模式：

- **Full Sync**: 下载所有区块并执行每笔交易，构建完整状态树（存储所有账户/合约状态）
- **Snap Sync（默认）**: 快速下载快照（snapshot），避免全量回放历史交易

模块交互流程如下：

```
PeerSet (P2P 节点管理)
  │
  ├──> Downloader（调度区块下载）
  │     └──> Fetcher（从其他节点获取区块/交易）
  │
  └──> ChainSync（根据共识规则检查链合法性）
         └──> 向数据库写入区块、更新状态
```

### 2. 交易池管理与 Gas 机制

Geth 的交易池（TxPool）负责：

- 管理待打包交易（Pending）和未来交易（Queued）
- 验证签名、Nonce、Gas 等合法性
- 按 GasPrice/GasTip 排序，便于矿工打包

Gas 机制遵循 **EIP-1559** 规范：

```
交易费用 = GasUsed × (BaseFee + Min(GasTipCap, GasFeeCap - BaseFee))
```

主要逻辑：

- **BaseFee**：由协议自动调整的基础费用（随区块容量动态变化）
- **GasTipCap**：用户愿意给矿工的小费（可选）
- **GasFeeCap**：用户愿意支付的最高单价（上限）

核心模块：

```
core/tx_pool.go           // 交易池逻辑
core/feepool.go           // Gas 管理逻辑
```

### 3. EVM 执行环境构建

Geth 实现了 EVM（以太坊虚拟机），执行智能合约代码，计算状态变更和 Gas 消耗。

模块划分：

- `core/vm/evm.go`：EVM 执行主循环
- `core/vm/interpreter.go`：指令执行器（基于 opcode）
- `core/state/`：状态管理（账户、合约、存储）
- `core/vm/runtime.go`：合约部署与调用流程

交互流程：

```
NewTx → 预执行 → EVM → 状态变更 → 结果写入状态数据库（trie）
```

特性支持：

- 兼容多版本 EVM（Frontier、Istanbul、London、Shanghai…）
- 支持 REVERT、STATICCALL、CREATE2 等高级操作码

### 4. 共识算法实现（Ethash → PoS）

#### ⛏ Ethash（PoW，已废弃）

Geth 曾实现完整的 Ethash 算法（`consensus/ethash`）：

- `Seal()`：挖矿封装逻辑，计算 nonce
- `VerifySeal()`：校验区块的工作量证明

Ethash 特点：

- 基于 DAG 和 Keccak256 混合算法
- 内存密集，抗 ASIC，鼓励 GPU 挖矿

#### 🌱 PoS（合并后）

合并（The Merge）后，Geth 不再负责共识，而是通过 **Engine API** 与共识客户端（如 Prysm）交互。

模块：

- `consensus/clique`：测试链/私链使用的 PoA 共识
- `consensus/pos`（Engine API 实现）：
    - `ForkchoiceUpdated`
    - `NewPayload`
    - `GetPayload`

PoS 下的职责划分：

| 层     | 客户端角色        | 职责                         |
| ------ | ----------------- | ---------------------------- |
| 共识层 | Lighthouse、Prysm | 验证者轮换、出块、投票       |
| 执行层 | Geth              | 交易执行、状态更新、EVM 执行 |


## 账户状态存储模型

![账户状态存储模型](账户状态存储模型.png)

1. 世界状态树 (World State Trie) : 这是以太坊状态的核心。它是一个全局的键值映射结构，其中：
   
   - 键 (Key) 是以太坊账户地址的哈希值 ( keccak256(address) )。
   - 值 (Value) 是账户内容的 RLP (Recursive Length Prefix) 编码。这个账户内容由 `StateAccount` 结构体表示。
2. StateAccount : 每个账户在状态树中都由这个结构体表示，它包含四个核心字段：
   
   - Nonce : 账户发出的交易数量。
   - Balance : 账户的以太币余额。
   - CodeHash : 如果是合约账户，这里存储了合约代码的哈希值。对于外部账户，它是一个空字符串的哈希。
   - Root : 这是该账户 存储树 (Storage Trie) 的根哈希。这是实现状态嵌套的关键。
3. 账户存储树 (Storage Trie) : 每个合约账户都有自己独立的存储树，用于存储其内部状态变量。它也是一个键值映射：
   
   - 键 (Key) 是存储槽 (Storage Slot) 的哈希 ( keccak256(slot) )，通常是一个 32 字节的数字。
   - 值 (Value) 是存储在该槽中的具体数据，也是 RLP 编码的。
4. 抽象层 : Geth 通过不同的代码模块来管理这个模型：
   
   - `ethdb` : 最底层的键值数据库接口，通常由 LevelDB 或 PebbleDB 实现，负责数据的物理持久化。
   - `triedb` : 在 ethdb 之上实现了默克尔帕特里夏树。它负责将树的节点序列化并存入数据库，同时也处理节点的读取和更新。Geth 的 pathdb 是对传统 Trie 的一种性能优化。
   - `StateDB` : 这是核心的状态管理对象。它为上层应用（如 EVM 执行交易）提供了一个简洁的 API 来读取和修改账户状态。它内部维护了一个 stateObject 的缓存，避免了频繁的数据库读写，并将最终的状态变更批量提交到底层的 triedb 。

## 总结：Geth 的核心作用

Geth 是以太坊节点中承载交易处理、合约执行与状态存储的**大脑与引擎**，确保链上状态一致、数据可验证、用户请求可响应。随着 PoS 的推进，其职责更加专注于执行与网络通信层，成为合规、安全、高效的执行环境核心。